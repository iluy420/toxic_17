#include "stdafx.h"
#include "stdio.h"
#include "conio.h"
#include "stdlib.h"

#define STACK_OVERFLOW -100
#define STACK_UNDERFLOW -101
//#define OUT_OF_MEMORY   -102

typedef int T;
typedef struct Node_tag {
	T value;
	struct Node_tag *next;
} Node_t;

void push(Node_t **head, T value) {
	Node_t *tmp = new struct Node_tag; //malloc(sizeof(Node_t));
	if (tmp == NULL) {
		exit(STACK_OVERFLOW);
	}
	tmp->next = *head;
	tmp->value = value;
	*head = tmp;
}

void pop1(Node_t **head, T n) {
	Node_t *out;
	if ((*head) == NULL) {
		exit(STACK_UNDERFLOW);
	}
	out = *head;
	if ((*head)->value == n) {
		*head = (*head)->next;
	}
	else {
		while (out) {
			if (out->next->value == n){
				out->next = out->next->next; 
				break;
			}
			out = out->next;
		}
	}

}
T pop2(Node_t **head) {
	Node_t *out;
	T value;
	if (*head == NULL) {
		exit(STACK_UNDERFLOW);
	}
	out = *head;
	*head = (*head)->next;
	value = out->value;
	free(out);
	return value;
}
T peek(const Node_t* head) {
	if (head == NULL) {
		exit(STACK_UNDERFLOW);
	}
	return head->value;
}
void printStack(const Node_t* head) {
	printf("stack >");
	while (head) {
		printf("%d ", head->value);
		head = head->next;
	}
}

size_t getSize(const Node_t *head) {
	size_t size = 0;
	while (head) {
		size++;
		head = head->next;
	}
	return size;
}
void main() {
	int i;
	Node_t *head = NULL, *tmp;
	for (i = 0; i < 50; i++) {
		push(&head, i);
	}
	tmp = head;
	printf("size = %d\n", getSize(head));
	printStack(head);
	pop1(&head, 30);
	printf("\n***********************************************************************************\n");
	printf("size = %d\n", getSize(head)); 
	printStack(head);
	
	_getch();
}